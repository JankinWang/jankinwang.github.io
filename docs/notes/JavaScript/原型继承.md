# 原型继承

>   推荐文章
>
>   https://juejin.cn/post/6844904093828251662
>
>   http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html
>
>   https://www.zybuluo.com/cherishpeace/note/21875

## 用 Object.create()  实现

```js
// 猫对象的构造函数
function Cat() {
    this.color = 'red'
}

// 添加原型方法 "喵"
Cat.prototype.miao = function() {
    alert('喵喵喵。。。')
}

// 老李的猫
function Licat() {
   this.name = 'Li Kiti'
   this.color = 'white' 
}

Licat.prototype = Object.create(Cat.prototype)
```



## 利用空函数作架桥函数，实现原型继承

>   1.子函数实例能够调用父函数中实例，即实现继承。
>
>   2.子函数可以扩展自己的方法，而不影响父函数。

```javascript
// 猫对象的构造函数
function Cat() {
    this.color = 'red'
}

// 添加原型方法 "喵"
Cat.prototype.miao = function() {
    alert('喵喵喵。。。')
}

// 老李的猫
function Licat() {
   // 解决了原型链继承中构造函数引用类型共享的问题 (搜索: 构造函数继承)
   Parent.call(this)
    
   this.name = 'Li Kiti'
   this.color = 'white' 
}

// 老李的猫要继承自猫
//中间函数
function F() {}

F.prototype = new Cat() // 继承Cat的一个实例
// 或者
F.prototype = Cat.prototype // 只继承Cat的原型上的方法或属性

// 完成继承
Licat.prototype = new F()
Licat.prototype.constructor = Licat

// 创建老李的猫
let catOfLi = new Licat()

// 叫唤
catOfLi.miao()


```

### 别人的实现

```javascript


      function Parent() {
        this.name = 'fedaily'
      }

      Parent.prototype.getName = function () {
        return this.name
      }

      function Child() {
        Parent.call(this)
        this.topic = 'fe'
      }

      // 仔细看这个函数的实现
      inherit(Child, Parent)

      function inherit(child, parent) {
        var prototype = object(parent.prototype)
        prototype.constructor = child
        child.prototype = prototype
      }

      // 这个函数的作用可以理解为复制了一份父类的原型对象
      // 如果直接将子类的原型对象赋值为父类原型对象
      // 那么修改子类原型对象其实就相当于修改了父类的原型对象
      function object(o) {
        function F() { }
        F.prototype = o;
        return new F();
      }

      console.log(new Child())
```

