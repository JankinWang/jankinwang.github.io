(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{481:function(n,e,t){"use strict";t.r(e);var s=t(45),a=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"查询数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查询数据"}},[n._v("#")]),n._v(" 查询数据")]),n._v(" "),t("h3",{attrs:{id:"select"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[n._v("#")]),n._v(" SELECT")]),n._v(" "),t("div",{staticClass:"language-mysql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/* SELECT */ ------------------\nSELECT [ALL|DISTINCT] select_expr FROM -> WHERE -> GROUP BY [合计函数] -> HAVING -> ORDER BY -> LIMIT\na. select_expr\n    -- 可以用 * 表示所有字段。\n        select * from tb;\n    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）\n        select stu, 29+25, now() from tb;\n    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。\n        - 使用 as 关键字，也可省略 as.\n        select stu+10 as add10 from tb;\nb. FROM 子句\n    用于标识查询来源。\n    -- 可以为表起别名。使用as关键字。\n        SELECT * FROM tb1 AS tt, tb2 AS bb;\n    -- from子句后，可以同时出现多个表。\n        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。\n        SELECT * FROM tb1, tb2;\n    -- 向优化符提示如何选择索引\n        USE INDEX、IGNORE INDEX、FORCE INDEX\n        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;\n        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;\nc. WHERE 子句\n    -- 从from获得的数据源中进行筛选。\n    -- 整型1表示真，0表示假。\n    -- 表达式由运算符和运算数组成。\n        -- 运算数：变量（字段）、值、函数返回值\n        -- 运算符：\n            =, <=>, <>, !=, <=, <, >=, >, !, &&, ||,\n            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor\n            is/is not 加上ture/false/unknown，检验某个值的真假\n            <=>与<>功能相同，<=>可用于null比较\nd. GROUP BY 子句, 分组子句\n    GROUP BY 字段/别名 [排序方式]\n    分组后会进行排序。升序：ASC，降序：DESC\n    以下[合计函数]需配合 GROUP BY 使用：\n    count 返回不同的非NULL值数目  count(*)、count(字段)\n    sum 求和\n    max 求最大值\n    min 求最小值\n    avg 求平均值\n    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。\ne. HAVING 子句，条件子句\n    与 where 功能、用法相同，执行时机不同。\n    where 在开始时执行检测数据，对原数据进行过滤。\n    having 对筛选出的结果再次进行过滤。\n    having 字段必须是查询出来的，where 字段必须是数据表存在的。\n    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。\n    where 不可以使用合计函数。一般需用合计函数才会用 having\n    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。\nf. ORDER BY 子句，排序子句\n    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...\n    升序：ASC，降序：DESC\n    支持多个字段的排序。\ng. LIMIT 子句，限制结果数量子句\n    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。\n    limit 起始位置, 获取条数\n    省略第一个参数，表示从索引0开始。limit 获取条数\nh. DISTINCT, ALL 选项\n    distinct 去除重复记录\n    默认为 all, 全部记录\ni. 拼接字段 Concat()函数\n\tselect Concat(first_name,'_',last_name) as name from strdent;\n\t\n")])])]),t("h3",{attrs:{id:"连接查询-join"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连接查询-join"}},[n._v("#")]),n._v(" 连接查询(join)")]),n._v(" "),t("div",{staticClass:"language-mysql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/* 连接查询(join) */ ------------------\n    将多个表的字段进行连接，可以指定连接条件。\n-- 内连接(inner join)\n    - 默认就是内连接，可省略inner。\n    - 只有数据存在时才能发送连接。即连接结果不能出现空行。\n    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）\n    也可用where表示连接条件。\n    还有 using, 但需字段名相同。 using(字段名)\n    -- 交叉连接 cross join\n        即，没有条件的内连接。\n        select * from tb1 cross join tb2;\n-- 外连接(outer join)\n    - 如果数据不存在，也会出现在连接结果中。\n    -- 左外连接 left join\n        如果数据不存在，左表记录会出现，而右表为null填充\n    -- 右外连接 right join\n        如果数据不存在，右表记录会出现，而左表为null填充\n-- 自然连接(natural join)\n    自动判断连接条件完成连接。\n    相当于省略了using，会自动查找相同字段名。\n    natural join\n    natural left join\n    natural right join\nselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;\n")])])]),t("h3",{attrs:{id:"union"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#union"}},[n._v("#")]),n._v(" UNION")]),n._v(" "),t("div",{staticClass:"language-mysql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/* UNION */ ------------------\n    将多个select查询的结果组合成一个结果集合。\n    SELECT ... UNION [ALL|DISTINCT] SELECT ...\n    默认 DISTINCT 方式，即所有返回的行都是唯一的\n    建议，对每个SELECT查询加上小括号包裹。\n    ORDER BY 排序时，需加上 LIMIT 进行结合。\n    需要各select查询的字段数量一样。\n    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。\n")])])]),t("h3",{attrs:{id:"子查询"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#子查询"}},[n._v("#")]),n._v(" 子查询")]),n._v(" "),t("div",{staticClass:"language-mysql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/* 子查询 */ ------------------\n    - 子查询需用括号包裹。\n-- from型\n    from后要求是一个表，必须给子查询结果取个别名。\n    - 简化每个查询内的条件。\n    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。\n    - 子查询返回一个表，表型子查询。\n    select * from (select * from tb where id>0) as subfrom where id>1;\n-- where型\n    - 子查询返回一个值，标量子查询。\n    - 不需要给子查询取别名。\n    - where子查询内的表，不能直接用以更新。\n    select * from tb where money = (select max(money) from tb);\n    -- 列子查询\n        如果子查询结果返回的是一列。\n        使用 in 或 not in 完成查询\n        exists 和 not exists 条件\n            如果子查询返回数据，则返回1或0。常用于判断条件。\n            select column1 from t1 where exists (select * from t2);\n    -- 行子查询\n        查询条件是一个行。\n        select * from t1 where (id, gender) in (select id, gender from t2);\n        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)\n        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。\n    -- 特殊运算符\n    != all()    相当于 not in\n    = some()    相当于 in。any 是 some 的别名\n    != some()   不等同于 not in，不等于其中某一个。\n    all, some 可以配合其他运算符一起使用。\n")])])]),t("h3",{attrs:{id:"使用通配符过滤数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用通配符过滤数据"}},[n._v("#")]),n._v(" 使用通配符过滤数据")]),n._v(" "),t("div",{staticClass:"language-mysql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- mysql中通过 LIKE 使用通配符\nselect * from student where name LIKE '%王';\n\n-- 通配符\n`%` -- 任何字符出现任意次数\n\t-- 'jet%' 表示以 `jet` 开头的字符串 （或'jet'后可以有多个任意字符）\n\t-- ‘%jet’ 表示以 `jet` 结尾的字符串\n\t-- '%jet%' 表示匹配任意位置包含 'jet' 的值\n\t\n`_` -- 匹配任意一个字符一次(与 % 类似)\n\n")])])]),t("blockquote",[t("p",[n._v("注：")]),n._v(" "),t("ul",[t("li",[n._v("不要过度使用通配符")]),n._v(" "),t("li",[n._v("不要把通配符放在搜索模式的开始处，如： where "),t("code",[n._v("name")]),n._v(" LIKE '%王'  AND id = 1；")])])]),n._v(" "),t("h3",{attrs:{id:"正则表达式匹配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式匹配"}},[n._v("#")]),n._v(" 正则表达式匹配")]),n._v(" "),t("div",{staticClass:"language-mysql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- eg:搜索以 `(大)` 结尾的菜名\nSELECT `store_menu_name` FROM dc_order_info WHERE store_menu_name REGEXP '.+(大)';\n\n-- 与 LIKE 相比LIKE会匹配整个列，而正则表达会所匹配的列中只要包含符合规则的字符就会被返还\n\n-- 转义字符： 如果要匹配特殊字符 如 . | \\ 应该写成 \\\\.  \\\\|  \\\\\\\n-- mysql 中需要用 \\\\ 转义,而不是 \\。 因为： mysql自己解释一个反斜杠 ， 正则表达式库解释一个反斜杠 \n\n-- 空白元字符\n-- [元字符]    [说明]\n--  \\\\f\t       换页\n--  \\\\n\t\t   换行\n--  \\\\r\t\t   回车\n--  \\\\t        制表符\n--  \\\\v        纵向制表符\n\n-- 定位元字符\n`^` 定义一行字符要以什么开头\n`$` 定义一行字符要以什么结尾\n\n-- 正则表达式测试\nselect ‘hello’ REGEXP 'hel.+'; -- 0 没有匹配, 1 匹配\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);